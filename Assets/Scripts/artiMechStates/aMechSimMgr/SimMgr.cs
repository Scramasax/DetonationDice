/// Artimech
/// 
/// Copyright Â© <2017> <George A Lancaster>
/// Permission is hereby granted, free of charge, to any person obtaining a copy of this software 
/// and associated documentation files (the "Software"), to deal in the Software without restriction, 
/// including without limitation the rights to use, copy, modify, merge, publish, distribute, 
/// sublicense, and/or sell copies of the Software, and to permit persons to whom the Software 
/// is furnished to do so, subject to the following conditions:
/// The above copyright notice and this permission notice shall be included in all copies 
/// or substantial portions of the Software.
/// 
/// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, 
/// INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS 
/// FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT 
/// HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, 
/// TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR 
/// OTHER DEALINGS IN THE SOFTWARE.

using UnityEngine;
using System.Collections;
using System.Collections.Generic;

namespace Artimech
{
    public class SimMgr : stateMachineBase
    {
        [Header("SimMgr:")]
        [SerializeField]
        [Tooltip("Min Random Time.")]
        float m_SpawnMinRndTime = 3.0f;
        [SerializeField]
        [Tooltip("Max Random Time.")]
        float m_SpawnMaxRndTime = 6.0f;

        private static SimMgr m_Instance = null;

        /// <summary>Returns an instance of SimMgr </summary>
        public static SimMgr Inst { get { return m_Instance; } }

        private IList<aMechDie> m_DiceList;
        private IList<aMechSpawnPoint> m_SpawnPointList;
        private IList<aMechGridPoint> m_GridPointList;

        public IList<aMechSpawnPoint> SpawnPointList
        {
            get
            {
                return m_SpawnPointList;
            }

            set
            {
                m_SpawnPointList = value;
            }
        }

        public IList<aMechDie> DiceList
        {
            get
            {
                return m_DiceList;
            }

            set
            {
                m_DiceList = value;
            }
        }

        public IList<aMechGridPoint> GridPointList
        {
            get
            {
                return m_GridPointList;
            }

            set
            {
                m_GridPointList = value;
            }
        }

        public float GetRandomSpawnTimeLimit()
        {
            float fltTemp = 0;
            fltTemp = Random.Range(m_SpawnMinRndTime, m_SpawnMaxRndTime);
            return fltTemp;
        }

        public void SpawnDieAtRandomSpawnPositions()
        {
            int rndIndex = Random.Range(0, m_SpawnPointList.Count - 1);
            m_SpawnPointList[rndIndex].Spawn = true;
        }

        public Vector3 GetClosestGridPoint(Vector3 pos)
        {
            Vector3 outVect = new Vector3();
            int index = -1;
            float distance = float.MaxValue;
            for(int i=0;i<GridPointList.Count;i++)
            {
                float dist = Vector3.Distance(pos, GridPointList[i].transform.position);
                if(dist<distance)
                {
                    index = i;
                    distance = dist;
                }
            }

            if (index != -1)
                return GridPointList[index].transform.position;

            return outVect;
        }

        new void Awake()
        {
            if (m_Instance != null)
            {
                Debug.LogWarning("There was already an instance of SimMgr.");
                return;
            }

            base.Awake();
            CreateStates();

            m_SpawnPointList = new List<aMechSpawnPoint>();
            DiceList = new List<aMechDie>();
            GridPointList = new List<aMechGridPoint>();

            m_Instance = GetComponent<SimMgr>();
        }

        // Use this for initialization
        new void Start()
        {
            base.Start();
        }

        // Update is called once per frame
        new void Update()
        {
            base.Update();
        }

        new void FixedUpdate()
        {
            base.FixedUpdate();
        }

        /// <summary>
        /// Autogenerated state are created here inside this function.
        /// </summary>
        void CreateStates()
        {

            m_CurrentState = AddState(new simMgrStart(this.gameObject), "simMgrStart");

            //<ArtiMechStates>
            AddState(new simMgrTriggerSpawn(this.gameObject), "simMgrTriggerSpawn");
            AddState(new simMgrStartGame(this.gameObject), "simMgrStartGame");
            AddState(new simMgrGameOverEnd(this.gameObject), "simMgrGameOverEnd");
            AddState(new simMgrGameOverStart(this.gameObject), "simMgrGameOverStart");
            AddState(new simMgrUpdate(this.gameObject), "simMgrUpdate");

        }
    }
}